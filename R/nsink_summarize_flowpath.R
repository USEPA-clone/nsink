#' Summarize nitrogen removal along a flowpath
#'
#' Nitrogen removal varies along a flowpath as they include different land cover
#' and waterbody types that have different nitrogen reduction capabilities.
#' This function takes a flowpath generated by
#' \code{\link{nsink_generate_flowpath}} as required input and returns and
#' estimate of total flow path removal as well as removal by type.
#'
#'
#' @param flowpath a flowpath to summarize nitrogen removal
#' @param removal the removal raster stack or removal list, generated by
#'                \code{\link{nsink_calc_removal}}
#' @return A data frame is returned that with a summary of nitrogen removal
#'
#' @importFrom zoo rollmax
#' @importFrom raster rasterize extract
#' @importFrom rlang .data
#' @export
#' @examples
#' \dontrun{
#' library(nsink)
#' niantic_huc <- nsink_get_huc_id("Niantic River")$huc_12
#' niantic_data <- nsink_get_data(niantic_huc, data_dir = "nsink_data")
#' aea <- "+proj=aea +lat_1=29.5 +lat_2=45.5 +lat_0=23 +lon_0=-96 +x_0=0 +y_0=0
#' +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"
#' niantic_nsink_data <- nsink_prep_data(niantic_huc, projection = aea,
#'                                       data_dir = "nsink_data")
#' removal <- nsink_calc_removal(niantic_nsink_data)
#' pt <- c(1948121, 2295822)
#' start_loc <- st_sf(st_sfc(st_point(c(pt)), crs = aea))
#' fp <- nsink_generate_flowpath(start_loc, niantic_nsink_data)
#' flow_summary <- nsink_summarize_flowpath(fp, removal)
#' flow_summary
#' }
nsink_summarize_flowpath <- function(flowpath, removal) {

  # Off Network based removal in flowpath ends

  land_off_network_removal <- suppressWarnings(st_intersection(
    flowpath$flowpath_ends[1,], removal$land_off_network_removal_type))

  land_off_network_removal <- suppressWarnings(st_intersection(
    removal$land_off_network_removal, land_off_network_removal))

  land_off_network_removal <- st_collection_extract(land_off_network_removal,
                                                    "LINESTRING")
  land_off_network_removal <- suppressWarnings(st_cast(land_off_network_removal,
                                                       "LINESTRING"))
  land_off_network_removal <- mutate(land_off_network_removal,
                                     edge_id = c(1:n()))
  land_off_network_removal
  browser()

  # Works up to hear.  Need to get this line ordered by flow
  # https://www.r-spatial.org/r/2019/09/26/spatial-networks.html

  nodes <- land_off_network_removal %>%
    st_coordinates() %>%
    as_tibble() %>%
    rename(edge_id = L1) %>%
    group_by(edge_id) %>%
    slice(c(1, n())) %>%
    ungroup() %>%
    mutate(start_end = rep(c('start', 'end'), times = n()/2)) %>%
    mutate(xy = paste(.$X, .$Y)) %>%
    mutate(node_id = group_indices(., factor(xy, levels = unique(xy)))) %>%
    select(-xy)

  source_nodes <- nodes %>%
    filter(start_end == 'start') %>%
    pull(node_id)

  target_nodes <- nodes %>%
    filter(start_end == 'end') %>%
    pull(node_id)

  land_off_network_removal <- mutate(land_off_network_removal,
                                     fromnode = source_nodes,
                                     tonode = target_nodes)

  # Maybe can do this the df way
  tidyr::gather(xx,key="node_type","nodes", 2:3) %>% arrange(nodes, edge_id) %>% pull(edge_id) -> xxx

  # or maybe order doesn't matter
  x <- runif(10,0.1,0.9)
  cumprod(c(100,sample(x,10, replace=F)))

  land_off_network_removal_df <- data.frame(
    stream_comid = 0, lake_comid = 0,
    n_removal = land_off_network_removal$layer,
    segment_type = land_off_network_removal$layer.1
  )
  land_off_network_removal_df <- mutate(land_off_network_removal_df,
                                        n_removal = case_when(
                                          is.na(.data$n_removal) ~ 0,
                                          .data$segment_type == 0 ~0,
                                          TRUE ~ .data$n_removal),
                                        segment_id = nsink_create_segment_ids(
                                          paste(.data$segment_type,.data$n_removal)),
                                        length = as.numeric(st_length(land_off_network_removal)))

  if (!is.null(flowpath$flowpath_network)) {
    n_removal_df <- select(
      st_drop_geometry(removal$network_removal),
      .data$stream_comid, .data$n_removal
    )
    flowpath_removal <- suppressMessages(left_join(flowpath$flowpath_network, n_removal_df))
    flowpath_removal_df <- st_drop_geometry(flowpath_removal)
    flowpath_removal_df <- unique(flowpath_removal_df)
    flowpath_removal_df <- mutate(flowpath_removal_df,
      segment_type =
        case_when(
          ftype == "ArtificialPath" ~
          "Lake/Pond",
          ftype == "StreamRiver" ~
          "Stream",
          TRUE ~ "Unknown"
        ),
      length = .data$lengthkm * 1000
    )
    flowpath_removal_df <- select(
      flowpath_removal_df, .data$stream_comid,
      .data$lake_comid, .data$n_removal, .data$segment_type, length
    )
    flowpath_removal_df <- mutate(flowpath_removal_df,
      segment_id =
        nsink_create_segment_ids(paste(
          .data$segment_type,
          .data$n_removal
        ))
    )
  } else {
    flowpath_removal_df <- NULL
  }

  removal_summary <- nsink_create_summary(land_off_network_removal_df,
                                          flowpath_removal_df)
  removal_summary <- mutate(removal_summary, length = round(length,0),
                            percent_removal = signif(.data$percent_removal, 3),
                            n_in = signif(.data$n_in, 3),
                            n_out = signif(.data$n_out, 3))
  return(removal_summary)
}


#' Create ID's for unique values in a vector
#'
#' This functions takes a vector of values and creates a unique ID for adjacent
#' and identical values.
#'
#' @param x a vector of values to create unique ID's
#'
#' @return a vector of unique ID's
#'
#' @keywords internal
nsink_create_segment_ids <- function(x) {
  y <- vector("numeric", length(x))
  y_id <- vector("numeric", length(x))
  for (i in seq_along(x)) {
    if (i == 1) {
      y[i] <- i
    } else {
      y[i] <- ifelse(x[i] == x[i - 1], FALSE, i)
    }
  }
  for (i in seq_along(y)) {
    if (i == 1) {
      y[1] <- y[1]
    } else {
      y[i] <- ifelse(y[i] == 0, y[i - 1], y[i])
    }
  }
  y
}

#' Create a nitrogen removal summary
#'
#' This functions takes a nitrogen removal and removal type data frame for land
#' and the flowpath network  and creates a data frame that summarizes the
#' removal along that flowpath.
#'
#' @param land_removal A data frame of land based nitrogen removal via the
#'                     generated flowpath and hydric removal raster.
#' @param network_removal A data frame of stream network nitrogen removal via
#'                        calculated stream and lake removal
#' @return a data frame summarizing nitrogen removal along a flowpath
#' @import dplyr
#' @importFrom rlang .data
#' @keywords internal
nsink_create_summary <- function(land_removal, network_removal) {
  land_removal_df <- mutate(land_removal,
    segment_type = case_when(
      segment_type == 0 ~ "No Removal",
      segment_type == 1 ~ "Hydric",
      segment_type == 2 ~ "Stream",
      segment_type == 3 ~ "Lake/Pond"
    )
  )
  land_removal_df <- group_by(land_removal_df, .data$segment_id, .data$segment_type)
  land_removal_df <- summarize(land_removal_df,
    length = sum(length),
    n_removal = max(.data$n_removal)
  )
  land_removal_df <- ungroup(land_removal_df)

  # Passing in and out of hydric soil can trigger removal at each step
  # This would result in unusually high removal
  # This calculates a weighted average across all hydric soils on land
  # Slight departure from original method in Kellogg et al.
  wgt_avg_removal <- function(length, removal) {
    sum(length * removal, na.rm = TRUE) / sum(length, na.rm = TRUE)
  }

  land_removal_df <- group_by(land_removal_df, .data$segment_type)
  land_removal_df <- summarize(land_removal_df,
    segment_id = max(.data$segment_id),
    n_removal = wgt_avg_removal(length, .data$n_removal),
    length = sum(length)
  )
  land_removal_df <- ungroup(land_removal_df)
  land_removal_df <- select(
    land_removal_df, .data$segment_id, .data$segment_type, length,
    .data$n_removal
  )
  if (!is.null(network_removal)) {
    # Multiple stream segments in a single lake also increases removal for a
    # lake by a factor of the number of segments.  This code results in only a
    # single n removal per lake based on that lakes estimated percent removal
    network_removal_df <- select(network_removal, .data$segment_id, .data$segment_type,
                                 length, .data$n_removal)
    network_removal_df <- group_by(network_removal_df, .data$segment_id)
    network_removal_df <- mutate(network_removal_df, length = sum(length))
    network_removal_df <- filter(network_removal_df, !duplicated(.data$segment_id))
    network_removal_df <- ungroup(network_removal_df)
    flowpath_removal_df <- rbind(land_removal_df, network_removal_df)
  } else {
    flowpath_removal_df <- land_removal_df
  }

  # Converting NA removal to 0
  flowpath_removal_df <- mutate(flowpath_removal_df,
    n_removal =
      case_when(
        is.na(.data$n_removal) ~ 0,
        TRUE ~ .data$n_removal
      )
  )

  n <- nrow(flowpath_removal_df)
  flowpath_removal_summary <- mutate(flowpath_removal_df,
    n_in = round(cumprod(c(100, 1 - .data$n_removal))[-n], 2),
    n_out = round(cumprod(c(100, 1 - .data$n_removal))[-1], 2),
    percent_removal = round(.data$n_removal * 100, 3)
  )
  flowpath_removal_summary <- select(
    flowpath_removal_summary, .data$segment_type,
    length, .data$percent_removal, .data$n_in, .data$n_out
  )

  flowpath_removal_summary
}
