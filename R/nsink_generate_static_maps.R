#' Generate N-Sink Static Maps for a given HUC
#'
#' @param input_data A list of input datasets created with
#'                   \code{\link{nsink_prep_data}}.
#' @param removal the removal raster stack or removal list, generated by
#'                \code{\link{nsink_calc_removal}}
#' @param samp_dens A value, in the units of the input data, divided by total area of
#'             the input HUC.  It is used to determine the number of points,
#'             determined through a regular sample, to calculate removal.  For
#'             instance a value of 90 would roughly equate to a point per every
#'             90 meters.
#' @param ncpu number of CPUs to use for calculating flowpath removal for larger
#'             (i.e. greater than 50) number of flowpaths.  Defaults to one
#'             minus the number of cores available.
#' @param seed Random seed to ensure reproducibility of sample point creation
#'             for transport maps. Default set to 23.
#' @return This function returns a list or rasters: nitrogen removal efficiency,
#'         nitrogen loading index, nitrogen transport index, and the
#'         nitrogen delivery index.
#'
#' @export
#' @examples
#' \dontrun{
#' library(nsink)
#' niantic_huc <- nsink_get_huc_id("Niantic River")$huc_12
#' niantic_data <- nsink_get_data(niantic_huc, data_dir = "nsink_data")
#' aea <- "+proj=aea +lat_0=23 +lon_0=-96 +lat_1=29.5 +lat_2=45.5 +x_0=0 +y_0=0
#' +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"
#' niantic_nsink_data <- nsink_prep_data(niantic_huc, projection = aea,
#'                                       data_dir = "nsink_data")
#' removal <- nsink_calc_removal(niantic_nsink_data)
#' static_maps <- nsink_generate_static_maps(niantic_nsink_data, removal,samp_dens = 900)
#' }
nsink_generate_static_maps <- function(input_data, removal, samp_dens,
                                       ncpu = future::availableCores() - 1,
                                       seed = 23) {

  # Suppressing warnings from raster due to proj
  suppressWarnings({
  # Create static rasters
  message("Creating removal efficiency map...")
  removal_map <- removal$raster_method[["layer.1"]]
  message("Creating the loading index map...")
  n_load_idx <- nsink_generate_n_loading_index(input_data)
  message("Creating the transport and delivery index maps...")
  n_delivery_heat <- 100 - nsink_generate_n_removal_heatmap(input_data,
    removal, samp_dens,
    ncpu = ncpu, seed
  )

  n_delivery_heat <- raster::projectRaster(
    n_delivery_heat,
    input_data$raster_template
  )
  n_load_idx <- raster::projectRaster(n_load_idx, input_data$raster_template,
    method = "ngb"
  )
  n_delivery_heat <- raster::projectRaster(n_delivery_heat, input_data$raster_template,
    method = "ngb"
  )
  n_delivery_index <- n_load_idx * n_delivery_heat


  static_maps <- lapply(list(removal_effic = removal_map, loading_idx = n_load_idx,
              transport_idx = n_delivery_heat,delivery_idx = n_delivery_index),
         function(x) signif(x, 3))
  })

  static_maps
}

#' Generates the Nitrogen Loading Index
#'
#' This function reclassifies the NLCD data to an index of Nitrogen loading.
#' The index ranges from 0 to 1.
#'
#' @param input_data list of input data
#' @keywords internal
nsink_generate_n_loading_index <- function(input_data) {
  nlcd <- input_data$nlcd
  rcl_m <- matrix(cbind(
    n_load_idx_lookup$codes,
    n_load_idx_lookup$n_loading_index
  ), ncol = 2)
  suppressWarnings(raster::reclassify(nlcd, rcl_m))
}

#' Generate Nitrogen Removal Heatmap
#'
#' Generates the heatmap
#' @param input_data A list of input datasets created with
#'                   \code{\link{nsink_prep_data}}.
#' @param removal the removal raster stack or removal list, generated by
#'                \code{\link{nsink_calc_removal}}
#' @param samp_dens A value, in the units of the input data, divided by total area of
#'             the input HUC.  It is used to determine the number of points,
#'             determined through a regular sample, to calculate removal.  For
#'             instance a value of 90 would roughly equate to a point per every
#'             90 meters.
#' @param ncpu number of CPUs to use for calculating flowpath removal for larger
#'             (i.e. greater than 50) number of flowpaths.  Defaults to one
#'             minus the number of cores available.
#' @param seed Random seed to ensure reproducibility of sample point creation
#'             across runs.  Default set to 23.
#' @import future furrr
#' @importFrom sf st_area st_sample st_sf st_sfc st_crs
#' @importFrom utils txtProgressBar setTxtProgressBar
#' @importFrom methods as
#'
#' @keywords internal
nsink_generate_n_removal_heatmap <- function(input_data, removal, samp_dens,
                                             ncpu = future::availableCores() - 1,
                                             seed = 23) {
  set.seed(seed)
  num_pts <- as.numeric(round(st_area(input_data$huc) / (samp_dens * samp_dens)))
  sample_pts <- st_sample(input_data$huc, num_pts, type = "regular")

  # for fewer points, the interp sample is done serially
  # for more points, it is done in parallel
  message(paste0(" Running ", length(sample_pts), " sampled flowpaths..."))

  if(num_pts < 50){

    pb <- txtProgressBar(max = length(sample_pts), style = 3)
    xdf <- data.frame(fp_removal = vector("numeric", length(sample_pts)))
    for(i in seq_along(st_geometry(sample_pts))){
      setTxtProgressBar(pb, i)
      pt <- sample_pts[i,]
      pt <- st_sf(st_sfc(pt, crs = st_crs(input_data$huc)))
      fp <- nsink_generate_flowpath(pt, input_data)
      fp_summary <- nsink_summarize_flowpath(fp, removal)
      xdf <- rbind(xdf, data.frame(fp_removal = 100 - min(fp_summary$n_out)))
    }
    close(pb)

    sample_pts_removal <- st_sf(sample_pts, data = xdf)

  } else {
    fp_removal <- function(pt, input_data, removal) {

      pt <- st_sf(st_sfc(pt, crs = st_crs(input_data$huc)))
      fp <- nsink_generate_flowpath(pt, input_data)
      fp_summary <- nsink_summarize_flowpath(fp, removal)
      data.frame(fp_removal = 100 - min(fp_summary$n_out))

    }

    future::plan(future::multiprocess, workers = ncpu)
    sample_pts_removal <- st_sf(sample_pts,
      data = furrr::future_map_dfr(
        sample_pts,
        function(x) {
          fp_removal(
            x, input_data,
            removal
          )
        }, .progress = TRUE)
    )
  }

  message("\n Interpolating sampled flowpaths...")
  num_pts <- round(units::set_units(st_area(input_data$huc), "m^2") / (30 * 30))
  interp_points <- suppressWarnings(as(
    st_sample(input_data$huc, as.numeric(num_pts), type = "regular"),
    "Spatial"
  ))

  #Suppressing warnings from raster/proj
  suppressWarnings({
  interp_points <- sp::SpatialPixels(interp_points)
  interpolated_pts <- gstat::idw(fp_removal ~ 1,
    as(sample_pts_removal, "Spatial"),
    interp_points,
    nmin = 5, nmax = 10,
    idp = 0.5, debug.level = 0
  )

  idw_n_removal_heat_map <- raster::raster(interpolated_pts)
  idw_n_removal_heat_map_agg <- raster::aggregate(idw_n_removal_heat_map, fun = max, fact = 3)
  })
  idw_n_removal_heat_map_agg

}
