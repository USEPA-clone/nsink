#' Generate N-Sink Static Maps for a given HUC
#'
#' @param input_data A list of input datasets created with
#'                   \code{\link{nsink_prep_data}}.
#' @param removal the removal raster stack or removal list, generated by
#'                \code{\link{nsink_calc_removal}}
#' @param fact A value, in the units of the input data, divided by total area of
#'             the input HUC.  It is used to determine the number of points,
#'             determined through a regular sample, to caluclate removal.  For
#'             instance a value of 90 would roughly equate to a point per every
#'             90 meters.
#' @param data_dir Base directory that contains N-Sink data folders and prepped
#'                 data.  Data may be downloaded with the
#'                 \code{\link{nsink_get_data}} function and prepared with the
#'                 \code{\link{nsink_prep_data}} function. A new folder named
#'                 "static_maps" with the .tif files will be created in this
#'                 folder.
#' @param custom_load Place holder for a custom loading index.  Currently uses
#'                    values culled from the literature.  Custom loads are not yet
#'                    implemented
#' @export
#' @examples
#' \dontrun{
#' library(nsink)
#' niantic_huc <- nsink_get_huc_id("Niantic River")$huc_12
#' niantic_data <- nsink_get_data(niantic_huc)
#' aea <- "+proj=aea +lat_1=29.5 +lat_2=45.5 +lat_0=23 +lon_0=-96 +x_0=0 +y_0=0
#' +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"
#' niantic_nsink_data <- nsink_prep_data(niantic_huc, projection = aea)
#' niantic_removal <- nsink_calc_removal(niantic_nsink_data)
#' nsink_generate_static_maps(niantic_nsink_data, niantic_removal, fact = 3000,
#'                            "nsink_data/")
#'}
nsink_generate_static_maps <- function(input_data, removal, fact,
                                       data_dir = normalizePath("nsink_data/"),
                                       custom_load = NULL){
  browser()
  # Check for/create/clean data directory
  data_dir <- nsink_fix_data_directory(data_dir)

  # Create static rasters
  removal_map <- removal$raster_method[["layer.1"]]
  n_load_idx <- nsink_generate_n_loading_index(input_data)
  n_removal_heat <- nsink_generate_n_removal_heatmap(input_data, removal, fact,
                                                     ncpu = 1)
  n_delivery_index <- n_load_idx * n_removal_heat

  # Write out static rasters to tif
  raster::writeRaster()
}

#' Generates the Nitrogen Loading Index
#'
#' This function reclassifies the NLCD data to an index of Nitrogen loading.
#' The index ranges from 0 to 1.
#'
#' @param input_data list of input data
#' @param custom_load Place holder for a custom loading index.  Currently uses
#'                    values culled from the literature and stored as a dataset,
#'                    \code{n_load_idx_lookup}, which is loaded with
#'                    \code{nsink}.  Custom loads are not yet implemented.
#' @keywords internal
nsink_generate_n_loading_index <- function(input_data, custom_load = NULL){

  nlcd <- input_data$nlcd
  #Need to add in NLCD codes
  rcl_m <- matrix(cbind(n_load_idx_lookup$codes,
                        n_load_idx_lookup$n_loading_index), ncol = 2)
  raster::reclassify(nlcd, rcl_m)
}

#' Generate Nitrogen Removal Heatmap
#'
#' Generates the heatmap
#' @param input_data A list of input datasets created with
#'                   \code{\link{nsink_prep_data}}.
#' @param removal the removal raster stack or removal list, generated by
#'                \code{\link{nsink_calc_removal}}
#' @param fact A value, in the units of the input data, divided by total area of
#'             the input HUC.  It is used to determine the number of points,
#'             determined through a regular sample, to caluclate removal.  For
#'             instance a value of 90 would roughly equate to a point per every
#'             90 meters.
#' @param ncpu number of CPUs to use for calculating flowpath removal
#' @importFrom sf st_area st_sample st_sf st_sfc st_crs
#'
#' @keywords internal
nsink_generate_n_removal_heatmap <- function(input_data, removal, fact, ncpu){
  browser()
  num_pts <- round(st_area(input_data$huc)/(fact*fact))
  sample_pts <- st_sample(input_data$huc, num_pts ,type = "regular")

  fp_removal <- function(pt, input_data, removal){
    pt <- st_sf(st_sfc(pt, crs = st_crs(input_data$huc)))
    fp <- nsink_generate_flowpath(pt, input_data, method = "hybrid")
    fp_summary <- nsink_summarize_flowpath(fp, removal, method = "hybrid")
    data.frame(fp_removal = 100-min(fp_summary$n_out))
  }

  sample_pts_removal <- st_sf(sample_pts,
                              data = purrr::map_df(sample_pts,
                                                   function(x)
                                                     fp_removal(x, input_data,
                                                                removal)))
  num_pts <- round(st_area(input_data$huc)/(30*30))
  interp_points <- as(st_sample(input_data$huc, num_pts ,type = "regular"),
                      "Spatial")
  interp_points <- sp::SpatialPixels(interp_points)
  #interp_points <- st_sf(interp_points, data = data.frame(fp_removal = NA))
  #try gstat::idw
  interpolated_pts <- gstat::idw(fp_removal ~ 1,
                                 as(sample_pts_removal, "Spatial"),
                                 interp_points,
                                 idp = 1.25)

  n_removal_heat_map <- raster::raster(interpolated_pts)
  n_removal_heat_map <- raster::aggregate(n_removal_heat_map, fact = 5)
  mapview::mapview(n_removal_heat_map)
}

